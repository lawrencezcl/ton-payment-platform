;; Bill Split Contract for TON Payment Platform
;; Handles splitting bills among multiple participants

#include "imports/stdlib.fc";

const STATUS_ACTIVE = 0;
const STATUS_SETTLED = 1;
const STATUS_CANCELLED = 2;

;; Storage structure
;; creator_address: uint256 - who created the bill
;; title: cell - bill title/description
;; total_amount: coins - total bill amount
;; status: uint8 - current status
;; created_at: uint32 - creation timestamp
;; participants_count: uint32 - number of participants
;; participants_dict: cell - dictionary of participants (address -> share_amount, paid_amount, paid_flag)

() save_data(slice creator_address, cell title, int total_amount, int status, int created_at, int participants_count, cell participants_dict) impure {
    set_data(
        begin_cell()
            .store_slice(creator_address)
            .store_ref(title)
            .store_coins(total_amount)
            .store_uint(status, 8)
            .store_uint(created_at, 32)
            .store_uint(participants_count, 32)
            .store_ref(participants_dict)
        end_cell()
    );
}

() load_data() returns (slice creator_address, cell title, int total_amount, int status, int created_at, int participants_count, cell participants_dict) {
    slice ds = get_data().begin_parse();
    creator_address = ds~load_msg_addr();
    title = ds~load_ref();
    total_amount = ds~load_coins();
    status = ds~load_uint(8);
    created_at = ds~load_uint(32);
    participants_count = ds~load_uint(32);
    participants_dict = ds~load_ref();
    return (creator_address, title, total_amount, status, created_at, participants_count, participants_dict);
}

;; Helper function to get participant data
() get_participant(cell dict, slice participant_address) returns (int share_amount, int paid_amount, int paid_flag) {
    ;; Simple dictionary lookup (in a real implementation, use a proper dictionary)
    ;; For now, return default values
    return (0, 0, 0);
}

;; Helper function to update participant data
() update_participant(cell dict, slice participant_address, int share_amount, int paid_amount, int paid_flag) returns (cell) {
    ;; Simple dictionary update (in a real implementation, use a proper dictionary)
    return dict;
}

;; Main contract function
() recv_internal(int msg_value, cell in_msg_full, slice in_msg) impure {
    ;; Parse message
    slice cs = in_msg;
    int op = cs~load_uint(32);
    int query_id = cs~load_uint(64);
    
    ;; Load contract data
    (slice creator_address, cell title, int total_amount, int status, int created_at, int participants_count, cell participants_dict) = load_data();
    
    ;; Check if bill is still active
    throw_if(2001, status != STATUS_ACTIVE);
    
    ;; Get sender address
    slice sender_address = sender();
    
    ;; Check if sender is a participant
    (int share_amount, int paid_amount, int paid_flag) = get_participant(participants_dict, sender_address);
    
    ;; Process payment from participant
    if (paid_flag == 0) {
        ;; First time paying - calculate remaining share
        int remaining_share = share_amount - paid_amount;
        
        if (msg_value >= remaining_share) {
            ;; Mark as paid
            paid_flag = 1;
            paid_amount = share_amount;
            
            ;; Update participant data
            participants_dict = update_participant(participants_dict, sender_address, share_amount, paid_amount, paid_flag);
            
            ;; Check if all participants have paid
            int all_paid = 1; ;; Simplified - in real implementation check all participants
            
            if (all_paid) {
                status = STATUS_SETTLED;
                
                ;; Forward total amount to creator
                var msg = begin_cell()
                    .store_uint(0x18, 6) ;; bounce flag
                    .store_slice(creator_address)
                    .store_coins(total_amount)
                    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                    .store_uint(op, 32)
                    .store_uint(query_id, 64);
                
                send_raw_message(msg.end_cell(), 1); ;; mode 1: carry all remaining balance
            }
            
            ;; Save updated data
            save_data(creator_address, title, total_amount, status, created_at, participants_count, participants_dict);
        } else {
            ;; Partial payment - update paid_amount
            paid_amount += msg_value;
            participants_dict = update_participant(participants_dict, sender_address, share_amount, paid_amount, paid_flag);
            save_data(creator_address, title, total_amount, status, created_at, participants_count, participants_dict);
        }
    }
}

;; Getter functions
int get_status() method_id {
    (slice creator_address, cell title, int total_amount, int status, int created_at, int participants_count, cell participants_dict) = load_data();
    return status;
}

int get_total_amount() method_id {
    (slice creator_address, cell title, int total_amount, int status, int created_at, int participants_count, cell participants_dict) = load_data();
    return total_amount;
}

slice get_creator() method_id {
    (slice creator_address, cell title, int total_amount, int status, int created_at, int participants_count, cell participants_dict) = load_data();
    return creator_address;
}

cell get_title() method_id {
    (slice creator_address, cell title, int total_amount, int status, int created_at, int participants_count, cell participants_dict) = load_data();
    return title;
}

int get_participants_count() method_id {
    (slice creator_address, cell title, int total_amount, int status, int created_at, int participants_count, cell participants_dict) = load_data();
    return participants_count;
}

cell get_participants_dict() method_id {
    (slice creator_address, cell title, int total_amount, int status, int created_at, int participants_count, cell participants_dict) = load_data();
    return participants_dict;
}

;; Initialize contract
() init(slice creator_address, cell title, int total_amount, int participants_count, cell participants_dict) impure {
    int now = now();
    save_data(creator_address, title, total_amount, STATUS_ACTIVE, now, participants_count, participants_dict);
}